import { Meta, Story, Canvas } from '@storybook/addon-docs'
import { useState } from 'react'
import {
  StaticButton,
  StatefulButton,
  getInputStyles,
  InputState,
  applyStyles,
  makeTheme,
  StatefulInput,
  StatefulInputProps,
  ShallotProvider,
} from '@shallot-ui/web'

<Meta title="üîå Extending / Custom Styles" />

#### üö® This is an advanced topic! You don't need it to use our core components in your project.

<hr />

# üíÖ Writing Custom Styles

Shallot makes it easy to create new styling logic without having to re-write markup or state management for standard components. In this guide, we'll explore how the core concepts for creating new styles using existing components.

First, it's important to understand the types of components we use in Shallot. **Most components in Shallot come in two parts:**

1. A **static** component which accepts the core props for the component and a special prop called `styles` which is an object of shallot theme tokens. This component is responsible for the presentation of the component, and is not aware of any state.
2. A **stateful** component which manages a static component, and adds stateful behaviour to it. Stateful components have a special prop called `getStyles` which provides a single argument containing their state, and expects a `styles` object in return.

## Static Components

Let's start by exploring how a static component is styled using the `styles` object.

As an example, we'll look at the `<StaticButton />` component. This component is responsible for the presentation of a simple button. The `StaticButton` consists of a Container and a Label. The Container is a Shallot `<Row />` component, and the Label is a Shallot `<Text />` component. The `styles` property looks like this:

```ts
interface ButtonComponentStyles {
  container?: RowProps
  label?: TextProps
}
```

We can use the `styles` prop to style the container and label of the button. Since the prop is a simple JavaScript object, we can save our styles to a variable and reuse them in multiple places. This is similar to the concept of a "variant" in other component libraries.

```tsx
import {
  StaticButton,
  StaticButtonProps,
  ButtonComponentStyles,
} from '@shallot-ui/web'

const buttonStyles: ButtonComponentStyles = {
  container: {
    backgroundColor: 'Primary.300',
    elevation: 'pressable',
    cursor: 'pointer',
  },
  label: {
    fontSize: 'md',
    textColor: 'Shading.100',
    lineHeight: 'md',
    unitsAround: 2,
    unitsAbove: 1,
    unitsBelow: 1,
    centerText: true,
    flex: 1,
    cursor: 'pointer',
    userSelect: 'none',
  },
}

const CustomButton = (props: Omit<StaticButtonProps, 'styles'>) => (
  <StaticButton styles={buttonStyles} {...props} />
)
```

Notice that many of these styles are references to theme tokens. You can see an example below of what the button looks like when rendered using the default theme, but these values can be overridden by passing a custom theme to the `<ShallotProvider />` component.

### ‚ñ∂Ô∏è Live Example

<Canvas>
  <ShallotProvider>
    <StaticButton
      title="Hello World!"
      styles={{
        container: {
          backgroundColor: 'Primary.300',
          elevation: 'pressable',
          cursor: 'pointer',
          transition:
            'background-color 200ms ease-in-out, transform 300ms ease-in-out, box-shadow 300ms ease-in-out',
        },
        label: {
          fontSize: 'md',
          textColor: 'Shading.100',
          lineHeight: 'md',
          transition: 'color 300ms ease-in-out',
          unitsAround: 2,
          unitsAbove: 1,
          unitsBelow: 1,
          centerText: true,
          flex: 1,
          cursor: 'pointer',
          userSelect: 'none',
        },
      }}
    />
  </ShallotProvider>
</Canvas>

## Stateful Components

A stateful component is a component that manages the state of a corresponding static component. Instead of a `styles` prop, it has a `getStyles` prop which is a pure function which recieves a state object and returns the component's `styles` object.

To make our button stateful, we can simply inspect the button state provided as the first argument to our `getStyles` function, and update our styles object accordingly. Shallot provides a helpful `applyStyles` function that makes this easy to do.

```tsx
import {
  StatefulButton,
  StatefulButtonProps,
  ButtonState,
  applyStyles,
} from '@shallot-ui/web'

const getButtonStyles = (state: ButtonState) => {
  // First we define the base styles for our `<Button />`.
  let styles: ButtonComponentStyles = {
    // we'll use our styles from the previous example.
    ...buttonStyles,
  }

  // Next, we can change the styles when the button is hovered.
  // This is because the `StatefulButton` component defines a `hovered` state.
  if (state.hovered)
    styles = applyStyles(styles, {
      container: {
        backgroundColor: 'Primary.250',
        elevation: 'hover',
      },
    })

  // We can also change the styles when the button is focused.
  if (state.focused)
    styles = applyStyles(styles, {
      container: { elevation: 'focused' },
    })

  return styles
}

const CustomButton = (props: StatefulButtonProps) => (
  <StatefulButton getStyles={getButtonStyles} {...props} />
)
```

## Extending `getStyles` Functions

Many components come with their own style functions. For example, the `StatefulInput` component comes with a `getInputStyles` style function. Let's take a look at how we can extend this style function to create a new component.

```tsx
import {
  StatefulInput,
  StatefulInputProps,
  getInputStyles,
  InputState,
  applyStyles,
} from '@shallot-ui/web'

// Let's make a MagicInput component that only "reveals" its value on hover.
const getMagicInputStyles = (state: InputState) => {
  const { getStyles } = getInputStyles({})
  const baseStyles = getStyles(state)
  return applyStyles(baseStyles, {
    input: {
      // For sake of this example, we'll dim the text color rather than
      // hiding it entirely with `textColor: 'transparent'`
      textColor: state.hovered ? 'Shading.500' : 'Shading.200',
      transition: 'color 0.2s ease-in-out',
    },
  })
}

const MagicInput = (props: StatefulInputProps) => (
  <StatefulInput getStyles={getMagicInputStyles} {...props} />
)
```

### ‚ñ∂Ô∏è Live Example

And voila, below you'll see the result of our MagicInput component. Notice how the text color changes when we hover over the input.

<Canvas>
  <ShallotProvider>
    <StatefulInput
      value="Shallot is awesome!"
      getStyles={(state) => {
        const { getStyles } = getInputStyles({})
        const baseStyles = getStyles(state)
        return applyStyles(baseStyles, {
          input: {
            textColor: state.hovered ? 'Shading.500' : 'Shading.200',
            transition: 'color 0.2s ease-in-out',
          },
        })
      }}
    />
  </ShallotProvider>
</Canvas>

You can already begin to see from these examples how powerful the `getStyles` function is. The more you write Shallot components, the more you'll discover that even very complex components in your application can be built from simple compositions of static components and a `getStyles` function.

Next we'll combine these concepts with style props to uncover an incredibly satisfying developer experience!
