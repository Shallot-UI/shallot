import { Column, H1, P, Row, Button, getColor } from '@shallot-ui/next'
import {
  Callout,
  Collapsable,
  NarrativeText,
  Slides,
  ThemeSelector,
} from '@/components'

import Diamond from './Diamond'

# Shallot UI

<ThemeSelector />

- White labeling
- Themed content

> I'm a big fan of [Styled Components](https://styled-components.com/), it's the best way to write styles while still "thinking in react". Over the years, I've gravitated towards a set of tools that have made it enough without the bloat of a UI kit. Things like a standard theme object, mixins, variants, common components, and style props provide a great developer experience without the bloat of a full component library.

> Shallot is my attempt to formalize these patterns. It's entirely open-sourced (MIT) and published on `npm`, but it should read more like an essay. I'm not planning to develop or maintain the packages beyond my own uses. Many of these tools have been used in production projects for years. I hope you'll find it useful.

-- [Mitchell Butler](https://mitchellbutler.com)

<Callout unitsAbove={2}>
  Looking for installation instructions? Head over to the
  [installation](/installation/overview) page.
</Callout>

## What is a shallot?

Our base unit is an object called a "shallot". If you've ever written an inline style in React, you know how to write a shallot.

```ts
// Every valid style object is a valid shallot
const myFirstShallot: ShallotProp = {
  fontFamily: 'Inter, sans-serif',
  fontSize: 20,
  fontWeight: 600,
}
```

Writing styles as objects offers **a lot of natural benefits:**

- There's no context switching between languages.
- JS objects can be computed and extended.
- Objects can be typed (with TypeScript) and validated.
- We can easily serialize them for API calls.
- Style exceptions can be monitored in the same way as any others.

### Mixins

One key difference between shallots and style objects is the support for mixins. Mixins are simple functions that return a calculated value or a theme token. In practice, shallots consist primarily of mixins. You can think of them less as styles and more as a set of instructions for how to calculate a style from the theme.

```ts
import { getFontFamily, getFontSize, getGlobal } from '@shallot-ui/react'

const mySecondShallot: ShallotProp = {
  fontFamily: getFontFamily('Body'),
  fontSize: getFontSize('md'),
  color: getGlobal('foregroundColor'),
  fontWeight: 600,
}
```

We provide many out of the box, but they're also quite simple to create. For example, [here's the `getFontSize` mixin](https://github.com/Shallot-UI/shallot/blob/main/core/mixins/src/getFontSize/index.ts).

<Callout>
  **Concerned about performance?** Mixins are incredibly light and
  styled-components [supports server-side
  optimiziations](https://nextjs.org/docs/app/building-your-application/styling/css-in-js#styled-components)
  in frameworks like Next.
</Callout>

### Layering

Shallots can have multiple layers (hence the name). Layering allows you to define a single shallot for a more complex component. For example, a button has a container and a title, and different states. This allows shallots to act like component variants in other systems â€” single tokens that define the entire style for a component.

```ts
import {
  Button,
  ButtonShallot,
  getFontFamily,
  getFontSize,
  getGlobal,
  getRadius,
} from '@shallot-ui/react'

const primaryButton: ShallotProp = {
  Container: {
    backgroundColor: getColor('Primary', 500),
    borderRadius: getRadius('md'),
  },
  Title: {
    fontFamily: getFontFamily('UI'),
    fontSize: getFontSize('md'),
    color: getGlobal('buttonForegroundColor'),
    fontWeight: 600,
  },
  // A state has the same structure as the base shallot.
  ':hover': {
    Container: { backgroundColor: getColor('Primary', 600) },
    Title: { textDecoration: 'underline' },
  },
  // States don't have to be valid CSS pseudo-classes.
  ':loading': {
    Container: { backgroundColor: getColor('Shading', 400) },
  },
}

const MyApp = () => (
  <Button title="I'm a button" shallot={primaryButton} />
)
```

In fact, the base theme includes a `variants` object that can be used to store and reference shallots. You can see here how we could **use our primary button shallot as a variant:**

```tsx
import { ShallotProvider, Button } from '@shallot-ui/react'

const MyApp = () => (
  <ShallotProvider variants={{ Button: { primary: primaryButton } }}>
    <Button title="I'm a button" variant="primary" />
  </ShallotProvider>
)
```

<Callout>
  Theme variants can be useful in some cases where common components should
  share a set of styles, but in many cases simply using a shallot is sufficient
  and easier to optimize.
</Callout>

## Writing markup

As we've seen, shallots can be provided to components as a "shallot" prop. This prop is available to all shallot components. Unlike other approaches, this is not new syntax. We use only plain react, so you won't need to change how you build, lint, or test your app. **Creating a component that accepts a shallot prop is simple:**

```tsx
import { withBoxShallot } from '@shallot-ui/react'

const Diamond = withBoxShallot('div', {
  height: getUnits(1),
  width: getUnits(1),
  borderRadius: getRadius('sm'),
  backgroundColor: getColor('Shading', 500),
  transform: 'rotate(45deg)'
})

// use a dot in your markup
<Diamond shallot={{ backgroundColor: getColor('Primary', 200) }} />
```

At its root, each Shallot component is generally one of two types: `Box` or `Text`. Boxes position themselves and other objects on the page, while text components contain text. Both share many common layout props. Both also come with a `variant` prop.

You can also imagine how this allows you to use shallot only in limited areas of your app, or incrementally adopt it in existing components.

### Component vs layout styles

One way to think about this is the difference between padding and margin. Padding happens inside the bounds of the component, a component has a natural padding. On the other hand, margin is used to communicate and balance visual density on a page.

The right amount of margin around a component will depend on its surroundings. In this case, I think padding is a component style while margin is a layout style. Treating these two independently allows for some really nice possibilities.

```tsx
<Column variant="card" unitsAround={2} maxUnitWidth={30} alignCenter>
  <Row alignMiddle unitGap={1}>
    <Diamond />
    <H1>Example Card</H1>
  </Row>
  <P alignTextCenter>
    Here's a card that uses the `<Diamond />` component defined above, and some
    other components and layout props.
  </P>
  <Row fullWidth alignMiddle unitGap={1} unitsAbove={1}>
    <Button title="Learn More" variant="Secondary" grow />
    <Button title="Get Started" grow />
  </Row>
</Column>
```

<Column shallot={{ backgroundColor: getColor('Shading', 700) }} alignCenter>
  <Column variant="card" unitsAround={2} maxUnitWidth={30} alignCenter>
    <Row alignMiddle unitGap={1}>
      <Diamond />
      <H1>Example Card</H1>
    </Row>
    <P alignTextCenter>
      Here's a card that uses the `<Diamond />` component defined above, and
      some other components and layout props.
    </P>
    <Row fullWidth alignMiddle unitGap={1} unitsAbove={1}>
      <Button title="Learn More" variant="Secondary" grow />
      <Button title="Get Started" grow />
    </Row>
  </Column>
</Column>

### Standard Components

## Defining a theme

Finally, we get to the theme.

### Cross-platform

Shallot provides cross-platform versions of many of its standard components. For example, this entire page could be adapted to React Native with a single line change:

```diff
- import { Column, Fold, H1, P } from '@shallot-ui/next'
+ import { Column, Fold, H1, P } from '@shallot-ui/native'
```
