import {
  Column,
  H1,
  H2,
  H3,
  P,
  Row,
  Text,
  Button,
  getColor,
  getUnits,
  Checkbox,
  Input,
  getRadius,
} from '@shallot-ui/next'
import { Callout, Collapsable, NarrativeText, Slides } from '@/components'

import Dot from './Dot'
import ThemeSelectorRibbon from './ThemeSelectorRibbon'

# Shallot UI

> During years of cross-platform work in `react` & `react-native`, I never found a design system library whose benefits were worth the limitations. Many systems seem promising until you leave the boundaries of the compenents they offer and have to find hacky ways to work around them. Others have such an imposing groove that everything you build starts to look the same.

> I've tried many different libraries looking for something that would allow me to write concise markup, use a single cross-platform approach to styling, and always use the best component for the job. Over time, I've landed on a

apply themes wholly or partially to an app,

Perhaps starting my career as a designer has left me too opinionated, but I think there's a clear gap in UI development for cross-project and cross-platform work. I want to be able to work quickly, I want to write legible markup, use a single approach to styling, white-label projects without pulling my hair out, and not be limited to the components of a given library.

> I've ended up using [Styled Components](https://styled-components.com/), as a CSS-in-JS solution since it's cross-platform and doesn't try to reinvent concepts already well established in `react` and `css`. Over time, I've built some of my own patterns and techniques that have made it feel more like a design system. Shallot is my attempt to formalize these patterns.

> All of this code is open-sourced (MIT) and published on `npm`. That said, I don't intend to develop or maintain it for uses other than my own. I'm sharing it so that

> Many of these tools have been used in production projects for years. I hope you'll find it useful.

-- [Mitchell Butler](https://mitchellbutler.com)

<Callout unitsAbove={2}>
  Looking for installation instructions? Head over to the
  [installation](/installation/overview) page.
</Callout>

## Themes

**Good design is consistent.** When all of the visual surfaces of a platform (e.g., website, apps, emails) share common language, they deliver a singular experience.

We build consistency by establishing constraints. In shallot, these are defined in a theme object that can be shared between applications in a platform. In a monorepo, this theme can be defined in its own `@repo/theme` package shared across apps.

A shallot theme consists of **three major parts:**

1. `tokens` - These are the shared values of the theme, for example the font sizes and color palettes. They follow standard values from libraries like Tailwind CSS.
2. `globals` - Globals are symbolic names like `backgroundColor` that can reference tokens or static values. They're useful for component reusability and theme modes like light vs. dark.
3. `variants` - Variants describe the mix of tokens, globals, and other values are used to style common components. Variants are built from layered style objects we call "shallots", we'll cover these in the next section.

To explore this, here are some controls over the theme. The color selection will change the theme tokens, the dark mode switch will change the global mode, and the headings selector will change the variants.

<ThemeSelectorRibbon />

After establishing a theme, we need to use connect it to our styles. For this, we have standard "mixins" like `getFontSize` or `getGlobal`. Each of these functions takes the theme and some arguments and returns a getter that's compatible with styled components. They can **pull specific keys from the theme:**

```tsx
import styled from 'styled-components'
import { getFontSize, getGlobal } from '@shallot/react'

const MyComponent = styled.div`
  font-size: ${getFontSize('md')};
  background-color: ${getGlobal('backgroundColor')};
`
```

## Shallots

The theme and mixins alone can be enough for many applications.

Our base unit is an object called a "shallot". A shallot is an object that maps style keys like `fontSize` or `lineHeight` to theme tokens and static values.

**Every valid style object is a valid shallot.** If you've ever written an inline style in React, you know how to write a shallot. That said, shallots offer some additional benefits like mixins and nesting that make them more powerful and more portable.

One key difference between shallots and style objects is the support for mixins. Mixins are simple functions that return a calculated value or a theme token. While a style object defines a set of styles, a shallot describes how to _construct_ a set of styles from the theme.

```ts
import { getFontFamily, getFontSize, getGlobal } from '@shallot-ui/react'

const mySecondShallot: ShallotProp = {
  fontFamily: getFontFamily('Body'),
  fontSize: getFontSize('md'),
  color: getGlobal('foregroundColor'),
  fontWeight: 600,
}
```

We provide many out of the box, but they're also quite simple to create. For example, [here's the `getFontSize` mixin](https://github.com/Shallot-UI/shallot/blob/main/core/mixins/src/getFontSize/index.ts).

### Layers

Shallots can have multiple layers (hence the name). Layering allows a single shallot to describe the styles for a component's different parts and states. For example, a button has a container and a title, and it might have different styles when it's hovered or loading. A shallot can **contain all of these styles in a single object:**

```ts
import { Button, ButtonShallot, getGlobal, getColor } from '@shallot-ui/react'

const primaryButton: ButtonShallot = {
  Container: { backgroundColor: getColor('Primary', 500) },
  Title: { color: getGlobal('buttonForegroundColor') },

  ':hover': {
    Container: { backgroundColor: getColor('Primary', 600) },
  },
}

const MyApp = () => (
  <Button title="Press Me!" shallot={primaryButton} />
)
```

## Components

Shallot comes with pre-built wrappers for many standard HTML components like headings, inputs, and checkboxes. You can **experiment with the variant selector in the header** to see how these are impacted by the theme.

```tsx
<Column variant="card" maxUnitWidth={30} unitGap={1}>
  <H2>Example Form</H2>
  <P>
    This is just an example of how a form can look. See how we can use standard
    HTML props?
  </P>
  <Input
    placeholder="Email Address"
    autoComplete="email"
    autoCapitalize={false}
  />
  <Row alignMiddle unitGap={1}>
    <Checkbox id="opt-in" />
    <Text as="label" for="opt-in">
      Send me offers & updates.
    </Text>
  </Row>
  <Button title="Submit" type="button" />
  <Button title="Skip" variant="Secondary" type="button" />
</Column>
```

<Row
  alignCenter
  alignMiddle
  shallot={{
    backgroundColor: getColor('Shading', 800),
    padding: getUnits(3),
    marginLeft: getUnits(-2),
    marginRight: getUnits(-2),
  }}
>
  <Column variant="card" maxUnitWidth={30} unitGap={1}>
    <H2>Example Form</H2>
    <P>
      This is just an example of how a form can look. See how we can use
      standard HTML props?
    </P>
    <Input
      placeholder="Email Address"
      autoComplete="email"
      autoCapitalize={false}
    />
    <Row alignMiddle unitGap={1}>
      <Checkbox id="opt-in" />
      <Text as="label" for="opt-in">
        Send me offers & updates.
      </Text>
    </Row>
    <Button title="Submit" type="button" />
    <Button title="Skip" variant="Secondary" type="button" />
  </Column>
</Row>

### Component vs layout styles

You'll notice a couple of new props in the example above: `unitGap` and `alignMiddle`. These are called "layout props". They impact the style of a component relative to to the rest of the page. Using props for layout like spacing and alignment means we can write markup that describes an entire page.

One way to think about this is the difference between padding and margin.
Padding happens inside the bounds of the component, a component has a natural
padding. On the other hand, margin is used to communicate and balance visual
density on a page. The right amount of margin around a component will depend on its surroundings.

A shallot might be applied to a component in its definition or directly through a `shallot={...}` prop. Defining a component that accepts both of these

```tsx
import { withShallot } from '@shallot-ui/react'

const Dot = withShallot('div', {
  height: getUnits(1),
  width: getUnits(1),
  borderRadius: getRadius('pill'),
  backgroundColor: getColor('Shading', 500),
})

const MyApp = () => <Dot />
```

This component also conveniently accepts a `shallot` prop, **which allows you to override the default styles:**

```tsx
<Dot shallot={{ backgroundColor: getColor('Primary', 200) }} />
```

At its root, each Shallot component is generally one of two types: `Box` or `Text`. Boxes (like `Row` and `Column`) contain and position objects on the page, while text components style text. Both share many common "layout props" to control their size and position relative to other components.

---

Now that you understand the basic building blocks of Shallot, you can start to see how you can use them to build your own components. The power of these patterns is in the flexibility.
